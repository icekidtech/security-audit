import { CallWithSyncFeeRequest } from "./lib/callWithSyncFee/types";
import { SponsoredCallRequest } from "./lib/sponsoredCall/types";
import { SignatureData, PayloadToSign, CallWithERC2771Request, ERC2771Type, CallWithSyncFeeERC2771Request, CallWithSyncFeeConcurrentERC2771Request, CallWithConcurrentERC2771Request } from "./lib/erc2771/types";
import { TransactionStatusResponse, TaskState } from "./lib/status/types";
import { BaseCallWithSyncFeeParams, Config, RelayRequestOptions, RelayResponse, SignerOrProvider } from "./lib/types";
export { CallWithSyncFeeRequest, CallWithERC2771Request, SponsoredCallRequest, RelayRequestOptions, TransactionStatusResponse, RelayResponse, SignatureData, PayloadToSign, ERC2771Type, CallWithSyncFeeERC2771Request, BaseCallWithSyncFeeParams, CallWithSyncFeeConcurrentERC2771Request, CallWithConcurrentERC2771Request, Config, SignerOrProvider, TaskState, };
export declare class GelatoRelay {
    #private;
    constructor(config?: Partial<Config>);
    /**
     * @param {Config} config Configuration
     */
    configure: (config: Partial<Config>) => void;
    private _getConfiguration;
    /**
     * @param {CallWithSyncFeeRequest} request - CallWithSyncFee request to be relayed by Gelato Executors
     * @param {RelayRequestOptions} [options] - Optional Relay configuration
     * @param {string} [sponsorApiKey] Optional Sponsor API key to be used for the call
     * @returns {Promise<RelayResponse>} Response object with taskId parameter
     *
     */
    callWithSyncFee: (request: CallWithSyncFeeRequest, options?: RelayRequestOptions, sponsorApiKey?: string) => Promise<RelayResponse>;
    /**
     * @param {CallWithSyncFeeERC2771Request | CallWithSyncFeeConcurrentERC2771Request} request - Call with sync fee: Sequential ERC2771 or Concurrent ERC2771 request to be relayed by Gelato Executors
     * @param {SignerOrProvider} signerOrProvider - BrowserProvider [front-end] or Signer [back-end] to sign the payload
     * @param {RelayRequestOptions} [options] - Optional Relay configuration
     * @param {string} [sponsorApiKey] Optional Sponsor API key to be used for the call
     * @returns {Promise<RelayResponse>} Response object with taskId parameter
     *
     */
    callWithSyncFeeERC2771: (request: CallWithSyncFeeERC2771Request | CallWithSyncFeeConcurrentERC2771Request, signerOrProvider: SignerOrProvider, options?: RelayRequestOptions, sponsorApiKey?: string) => Promise<RelayResponse>;
    /**
     * @param {SponsoredCallRequest} request SponsoredCallRequest to be relayed by the Gelato Executors.
     * @param {string} sponsorApiKey Sponsor API key to be used for the call
     * @param {RelayRequestOptions} [options] Optional Relay configuration
     * @returns {Promise<RelayResponse>} Response object with taskId parameter
     *
     */
    sponsoredCall: (request: SponsoredCallRequest, sponsorApiKey: string, options?: RelayRequestOptions) => Promise<RelayResponse>;
    /**
     * @param {CallWithERC2771Request | CallWithConcurrentERC2771Request} request - Sponsored: Sequential ERC2771 or Concurrent ERC2771 request to be relayed by Gelato Executors
     * @param {SignerOrProvider} signerOrProvider - BrowserProvider [front-end] or Signer [back-end] to sign the payload
     * @param {string} sponsorApiKey - Sponsor API key
     * @param {RelayRequestOptions} [options] - Optional Relay configuration
     * @returns {Promise<RelayResponse>} Response object with taskId parameter
     *
     */
    sponsoredCallERC2771: (request: CallWithERC2771Request | CallWithConcurrentERC2771Request, signerOrProvider: SignerOrProvider, sponsorApiKey: string, options?: RelayRequestOptions) => Promise<RelayResponse>;
    /**
     * @param {CallWithERC2771Request | CallWithConcurrentERC2771Request} request - Sequential ERC2771 or Concurrent ERC2771 request to be relayed by Gelato Executors
     * @param {SignerOrProvider} signerOrProvider - BrowserProvider [front-end] or Signer [back-end] to sign the payload
     * @param {ERC2771Type} type - ERC2771Type.CallWithSyncFee or ERC2771Type.SponsoredCall
     * @returns {Promise<SignatureData>} Response object with struct and signature
     *
     */
    getSignatureDataERC2771: (request: CallWithERC2771Request | CallWithConcurrentERC2771Request, signerOrProvider: SignerOrProvider, type: ERC2771Type) => Promise<SignatureData>;
    /**
     * @param {CallWithERC2771Request | CallWithConcurrentERC2771Request} request - Sequential ERC2771 or Concurrent ERC2771 request to be relayed by Gelato Executors
     * @param {SignerOrProvider} [signerOrProvider] - Optional BrowserProvider [front-end] or Signer [back-end] to sign the payload
     * @param {ERC2771Type} type - ERC2771Type.CallWithSyncFee or ERC2771Type.SponsoredCall
     * @returns {Promise<PayloadToSign>} Response object with struct and typed data
     *
     */
    getDataToSignERC2771: (request: CallWithERC2771Request | CallWithConcurrentERC2771Request, type: ERC2771Type, signerOrProvider?: SignerOrProvider) => Promise<PayloadToSign>;
    /**
     * @param {SignatureData["struct"]} struct - Struct that can be obtained from getSignatureDataERC2771
     * @param {SignatureData["signature"]} signature - Signature that can be obtained from getSignatureDataERC2771
     * @param {string} sponsorApiKey - Sponsor API key
     * @param {RelayRequestOptions} [options] - Optional Relay configuration
     * @returns {Promise<RelayResponse>} Response object with taskId parameter
     *
     */
    sponsoredCallERC2771WithSignature: (struct: SignatureData["struct"], signature: SignatureData["signature"], sponsorApiKey: string, options?: RelayRequestOptions) => Promise<RelayResponse>;
    /**
     * @param {SignatureData["struct"]} struct - Struct that can be obtained from getSignatureDataERC2771
     * @param {BaseCallWithSyncFeeParams} syncFeeParams - Call with Sync Fee parameters
     * @param {SignatureData["signature"]} signature - Signature that can be obtained from getSignatureDataERC2771
     * @param {RelayRequestOptions} [options] - Optional Relay configuration
     * @param {string} [sponsorApiKey] Optional Sponsor API key to be used for the call
     * @returns {Promise<RelayResponse>} Response object with taskId parameter
     *
     */
    callWithSyncFeeERC2771WithSignature: (struct: SignatureData["struct"], syncFeeParams: BaseCallWithSyncFeeParams, signature: SignatureData["signature"], options?: RelayRequestOptions, sponsorApiKey?: string) => Promise<RelayResponse>;
    /**
     * @param {bigint} chainId - Chain Id
     * @returns {Promise<boolean>} Boolean to demonstrate if Relay V2 is supported on the provided chain
     */
    isNetworkSupported: (chainId: bigint) => Promise<boolean>;
    /**
     * @returns {Promise<string[]>} List of networks where Relay V2 is supported
     */
    getSupportedNetworks: () => Promise<string[]>;
    /**
     * @param {bigint} chainId - Chain Id
     * @returns {Promise<boolean>} Boolean to demonstrate if the oracle is active on the provided chain
     */
    isOracleActive: (chainId: bigint) => Promise<boolean>;
    /**
     * @returns {Promise<string[]>} List of chain ids where the Gelato Oracle is active
     */
    getGelatoOracles: () => Promise<string[]>;
    /**
     * @param {bigint} chainId - Chain Id
     * @returns {Promise<string[]>} List of all payment tokens on the provided chain
     *
     */
    getPaymentTokens: (chainId: bigint) => Promise<string[]>;
    /**
     * @param {bigint} chainId - Chain Id
     * @param {string} paymentToken - Payment Token
     * @param {bigint} gasLimit - Gas Limit
     * @param {boolean} isHighPriority - Priority Level
     * @param {bigint} [gasLimitL1=BigInt(0)] - Gas Limit for Layer 1
     * @returns {Promise<bigint>} Estimated Fee
     *
     */
    getEstimatedFee: (chainId: bigint, paymentToken: string, gasLimit: bigint, isHighPriority: boolean, gasLimitL1?: bigint) => Promise<bigint>;
    /**
     * @param {string} taskId - Task Id
     * @returns {Promise<TransactionStatusResponse | undefined>} Transaction status of the task id
     *
     */
    getTaskStatus: (taskId: string) => Promise<TransactionStatusResponse | undefined>;
    /**
     * @param {callback} handler - Callback function to be called on every task status update
     *
     */
    onTaskStatusUpdate: (handler: (taskStatus: TransactionStatusResponse) => void) => void;
    /**
     * @param {callback} handler - Callback function to be unregistered from task status updates
     *
     */
    offTaskStatusUpdate: (handler: (taskStatus: TransactionStatusResponse) => void) => void;
    /**
     * @param {callback} handler - Callback function to be called on error
     *
     */
    onError: (handler: (error: Error) => void) => void;
    /**
     * @param {callback} handler - Callback function to be unregistered as an error handler
     *
     */
    offError: (handler: (error: Error) => void) => void;
    /**
     * @param {string} taskId - Task Id
     *
     */
    subscribeTaskStatusUpdate: (taskId: string) => Promise<void>;
    /**
     * @param {string} taskId - Task Id
     *
     */
    unsubscribeTaskStatusUpdate: (taskId: string) => Promise<void>;
}
