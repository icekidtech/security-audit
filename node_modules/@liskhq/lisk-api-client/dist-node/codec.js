"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeBlockJSON = exports.toBlockJSON = exports.fromBlockJSON = exports.encodeBlock = exports.decodeBlock = exports.toBlockAssetJSON = exports.fromBlockAssetJSON = exports.encodeAssets = exports.decodeAssets = exports.toTransactionJSON = exports.fromTransactionJSON = exports.encodeTransaction = exports.decodeTransaction = exports.decodeEventData = exports.decodeTransactionParams = exports.getAssetDataSchema = exports.getEventDataSchema = exports.getTransactionParamsSchema = void 0;
const lisk_codec_1 = require("@liskhq/lisk-codec");
const lisk_cryptography_1 = require("@liskhq/lisk-cryptography");
const EVENT_COMMAND_EXECUTION_RESULT = 'commandExecutionResult';
const standardEventDataSchema = {
    $id: '/block/event/standard/ui',
    type: 'object',
    required: ['success'],
    properties: {
        success: {
            dataType: 'boolean',
            fieldNumber: 1,
        },
    },
};
const getTransactionParamsSchema = (transaction, metadata) => {
    const moduleMeta = metadata.find(meta => meta.name === transaction.module);
    if (!moduleMeta) {
        throw new Error(`Module: ${transaction.module} is not registered.`);
    }
    const commandMeta = moduleMeta.commands.find(meta => meta.name === transaction.command);
    if (!commandMeta) {
        throw new Error(`Module: ${transaction.module} CommandID: ${transaction.command} is not registered.`);
    }
    return commandMeta.params;
};
exports.getTransactionParamsSchema = getTransactionParamsSchema;
const getEventDataSchema = (event, metadata) => {
    const moduleMetadata = metadata.find(meta => meta.name === event.module);
    if (!moduleMetadata) {
        throw new Error(`Module: ${event.module} is not registered.`);
    }
    const eventMetadata = moduleMetadata.events.find(meta => meta.name === event.name);
    if (!eventMetadata) {
        return event.name === EVENT_COMMAND_EXECUTION_RESULT ? standardEventDataSchema : undefined;
    }
    return eventMetadata.data;
};
exports.getEventDataSchema = getEventDataSchema;
const getAssetDataSchema = (blockVersion, asset, metadata) => {
    const moduleMeta = metadata.find(meta => meta.name === asset.module);
    if (!moduleMeta) {
        throw new Error(`Asset schema Module: ${asset.module} is not registered.`);
    }
    const assetMeta = moduleMeta.assets.find(meta => meta.version === blockVersion);
    if (!assetMeta) {
        throw new Error(`Asset schema for Module: ${asset.module} Version: ${blockVersion} is not registered.`);
    }
    return assetMeta.data;
};
exports.getAssetDataSchema = getAssetDataSchema;
const decodeTransactionParams = (transaction, metadata) => {
    if (!Buffer.isBuffer(transaction.params)) {
        return transaction;
    }
    const paramsSchema = (0, exports.getTransactionParamsSchema)(transaction, metadata);
    return {
        ...transaction,
        params: lisk_codec_1.codec.decode(paramsSchema, transaction.params),
    };
};
exports.decodeTransactionParams = decodeTransactionParams;
const decodeEventData = (event, metadata) => {
    const eventDataSchema = (0, exports.getEventDataSchema)(event, metadata);
    return {
        ...event,
        data: eventDataSchema ? lisk_codec_1.codec.decodeJSON(eventDataSchema, Buffer.from(event.data, 'hex')) : {},
    };
};
exports.decodeEventData = decodeEventData;
const decodeTransaction = (encodedTransaction, registeredSchema, metadata) => {
    const transaction = lisk_codec_1.codec.decode(registeredSchema.transaction, encodedTransaction);
    const paramsSchema = (0, exports.getTransactionParamsSchema)(transaction, metadata);
    const params = lisk_codec_1.codec.decode(paramsSchema, transaction.params);
    const id = lisk_cryptography_1.utils.hash(encodedTransaction);
    return {
        ...transaction,
        params,
        id,
    };
};
exports.decodeTransaction = decodeTransaction;
const encodeTransaction = (transaction, registeredSchema, metadata) => {
    let encodedParams;
    if (!Buffer.isBuffer(transaction.params)) {
        const paramsSchema = (0, exports.getTransactionParamsSchema)(transaction, metadata);
        encodedParams = lisk_codec_1.codec.encode(paramsSchema, transaction.params);
    }
    else {
        encodedParams = transaction.params;
    }
    const decodedTransaction = lisk_codec_1.codec.encode(registeredSchema.transaction, {
        ...transaction,
        params: encodedParams,
    });
    return decodedTransaction;
};
exports.encodeTransaction = encodeTransaction;
const fromTransactionJSON = (transaction, registeredSchema, metadata) => {
    const paramsSchema = (0, exports.getTransactionParamsSchema)(transaction, metadata);
    const tx = lisk_codec_1.codec.fromJSON(registeredSchema.transaction, {
        ...transaction,
        params: '',
    });
    let params;
    if (typeof transaction.params === 'string') {
        params = lisk_codec_1.codec.decode(paramsSchema, Buffer.from(transaction.params, 'hex'));
    }
    else {
        params = lisk_codec_1.codec.fromJSON(paramsSchema, transaction.params);
    }
    return {
        ...tx,
        id: transaction.id ? Buffer.from(transaction.id, 'hex') : Buffer.alloc(0),
        params,
    };
};
exports.fromTransactionJSON = fromTransactionJSON;
const toTransactionJSON = (transaction, registeredSchema, metadata) => {
    const paramsSchema = (0, exports.getTransactionParamsSchema)(transaction, metadata);
    if (Buffer.isBuffer(transaction.params)) {
        return {
            ...lisk_codec_1.codec.toJSON(registeredSchema.transaction, transaction),
            params: lisk_codec_1.codec.decodeJSON(paramsSchema, transaction.params),
            id: transaction.id.toString('hex'),
        };
    }
    return {
        ...lisk_codec_1.codec.toJSON(registeredSchema.transaction, {
            ...transaction,
            params: Buffer.alloc(0),
        }),
        params: lisk_codec_1.codec.toJSON(paramsSchema, transaction.params),
        id: transaction.id.toString('hex'),
    };
};
exports.toTransactionJSON = toTransactionJSON;
const decodeAssets = (blockVersion, encodedAssets, registeredSchema, metadata) => {
    const assets = encodedAssets.map(asset => lisk_codec_1.codec.decode(registeredSchema.asset, asset));
    const decodedAssets = [];
    for (const asset of assets) {
        const assetSchema = (0, exports.getAssetDataSchema)(blockVersion, { module: asset.module }, metadata);
        const decodedData = lisk_codec_1.codec.decode(assetSchema, asset.data);
        decodedAssets.push({
            ...asset,
            data: decodedData,
        });
    }
    return decodedAssets;
};
exports.decodeAssets = decodeAssets;
const encodeAssets = (blockVersion, assets, registeredSchema, metadata) => {
    const result = [];
    for (const asset of assets) {
        let encodedData;
        if (!Buffer.isBuffer(asset.data)) {
            const dataSchema = (0, exports.getAssetDataSchema)(blockVersion, { module: asset.module }, metadata);
            encodedData = lisk_codec_1.codec.encode(dataSchema, asset.data);
        }
        else {
            encodedData = asset.data;
        }
        const encodedAsset = lisk_codec_1.codec.encode(registeredSchema.asset, {
            ...asset,
            data: encodedData,
        });
        result.push(encodedAsset);
    }
    return result;
};
exports.encodeAssets = encodeAssets;
const fromBlockAssetJSON = (blockVersion, asset, registeredSchema, metadata) => {
    const dataSchema = (0, exports.getAssetDataSchema)(blockVersion, asset, metadata);
    if (typeof asset.data === 'string') {
        return {
            ...lisk_codec_1.codec.fromJSON(registeredSchema.asset, asset),
            data: lisk_codec_1.codec.decode(dataSchema, Buffer.from(asset.data, 'hex')),
        };
    }
    return {
        ...lisk_codec_1.codec.fromJSON(registeredSchema.asset, { ...asset, data: '' }),
        data: lisk_codec_1.codec.fromJSON(dataSchema, asset.data),
    };
};
exports.fromBlockAssetJSON = fromBlockAssetJSON;
const toBlockAssetJSON = (blockVersion, asset, registeredSchema, metadata) => {
    const dataSchema = (0, exports.getAssetDataSchema)(blockVersion, { module: asset.module }, metadata);
    if (Buffer.isBuffer(asset.data)) {
        return {
            ...lisk_codec_1.codec.toJSON(registeredSchema.asset, asset),
            data: lisk_codec_1.codec.decodeJSON(dataSchema, asset.data),
        };
    }
    return {
        ...lisk_codec_1.codec.toJSON(registeredSchema.asset, { ...asset, data: Buffer.alloc(0) }),
        data: lisk_codec_1.codec.toJSON(dataSchema, asset.data),
    };
};
exports.toBlockAssetJSON = toBlockAssetJSON;
const decodeBlock = (encodedBlock, registeredSchema, metadata) => {
    const block = lisk_codec_1.codec.decode(registeredSchema.block, encodedBlock);
    const header = lisk_codec_1.codec.decode(registeredSchema.header, block.header);
    const id = lisk_cryptography_1.utils.hash(block.header);
    const transactions = [];
    for (const tx of block.transactions) {
        transactions.push((0, exports.decodeTransaction)(tx, registeredSchema, metadata));
    }
    const decodedAssets = (0, exports.decodeAssets)(header.version, block.assets, registeredSchema, metadata);
    return {
        header: {
            ...header,
            id,
        },
        assets: decodedAssets,
        transactions,
    };
};
exports.decodeBlock = decodeBlock;
const encodeBlock = (block, registeredSchema, metadata) => {
    const encodedTransactions = block.transactions.map(p => (0, exports.encodeTransaction)(p, registeredSchema, metadata));
    const encodedAssets = (0, exports.encodeAssets)(block.header.version, block.assets, registeredSchema, metadata);
    const encodedBlockHeader = lisk_codec_1.codec.encode(registeredSchema.header, block.header);
    return lisk_codec_1.codec.encode(registeredSchema.block, {
        header: encodedBlockHeader,
        transactions: encodedTransactions,
        assets: encodedAssets,
    });
};
exports.encodeBlock = encodeBlock;
const fromBlockJSON = (block, registeredSchema, metadata) => {
    const header = lisk_codec_1.codec.fromJSON(registeredSchema.header, block.header);
    const id = lisk_cryptography_1.utils.hash(lisk_codec_1.codec.encode(registeredSchema.header, header));
    const transactions = [];
    for (const transaction of block.transactions) {
        transactions.push((0, exports.fromTransactionJSON)(transaction, registeredSchema, metadata));
    }
    const assets = [];
    for (const asset of block.assets) {
        assets.push((0, exports.fromBlockAssetJSON)(header.version, asset, registeredSchema, metadata));
    }
    return {
        header: {
            ...header,
            id,
        },
        transactions,
        assets,
    };
};
exports.fromBlockJSON = fromBlockJSON;
const toBlockJSON = (block, registeredSchema, metadata) => {
    const header = lisk_codec_1.codec.toJSON(registeredSchema.header, block.header);
    const transactions = [];
    for (const transaction of block.transactions) {
        transactions.push((0, exports.toTransactionJSON)(transaction, registeredSchema, metadata));
    }
    const assets = [];
    for (const asset of block.assets) {
        assets.push((0, exports.toBlockAssetJSON)(header.version, asset, registeredSchema, metadata));
    }
    return {
        header: {
            ...header,
            id: block.header.id.toString('hex'),
        },
        transactions,
        assets,
    };
};
exports.toBlockJSON = toBlockJSON;
const decodeBlockJSON = (block, metadata) => {
    const transactions = [];
    for (const transaction of block.transactions) {
        const params = Buffer.from(transaction.params, 'hex');
        const paramsSchema = (0, exports.getTransactionParamsSchema)(transaction, metadata);
        const paramsJSON = lisk_codec_1.codec.decodeJSON(paramsSchema, params);
        transactions.push({
            ...transaction,
            params: paramsJSON,
        });
    }
    const assets = [];
    for (const asset of block.assets) {
        const dataSchema = (0, exports.getAssetDataSchema)(block.header.version, asset, metadata);
        assets.push({
            ...asset,
            data: lisk_codec_1.codec.decodeJSON(dataSchema, Buffer.from(asset.data, 'hex')),
        });
    }
    return {
        header: block.header,
        transactions,
        assets,
    };
};
exports.decodeBlockJSON = decodeBlockJSON;
//# sourceMappingURL=codec.js.map