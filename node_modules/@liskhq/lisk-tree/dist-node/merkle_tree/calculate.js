"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateRootFromUpdateData = void 0;
const lisk_cryptography_1 = require("@liskhq/lisk-cryptography");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const calculateRootFromUpdateData = (updateData, proof) => {
    const { indexes, size, siblingHashes } = proof;
    if (size === 0 || indexes.length === 0) {
        throw new Error('Invalid proof.');
    }
    if (updateData.length !== indexes.length) {
        throw new Error("Amount of update data doesn't match amount of indexes");
    }
    const updateHashes = [];
    for (const data of updateData) {
        const leafValueWithoutNodeIndex = Buffer.concat([constants_1.LEAF_PREFIX, data], constants_1.LEAF_PREFIX.length + data.length);
        const leafHash = lisk_cryptography_1.utils.hash(leafValueWithoutNodeIndex);
        updateHashes.push(leafHash);
    }
    const calculatedTree = (0, utils_1.calculatePathNodes)(updateHashes, size, indexes, siblingHashes);
    const calculatedRoot = calculatedTree.get(utils_1.ROOT_INDEX);
    return calculatedRoot;
};
exports.calculateRootFromUpdateData = calculateRootFromUpdateData;
//# sourceMappingURL=calculate.js.map