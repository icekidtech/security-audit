/// <reference types="node" />
import { NodeLocation, MerkleRootInfo } from './types';
export declare const isLeaf: (value: Buffer) => boolean;
export declare const generateHash: (prefix: Buffer, leftHash: Buffer, rightHash: Buffer) => Buffer;
export declare const getMaxIdxAtLayer: (layer: number, size: number) => number;
export declare const getLayerStructure: (size: number) => number[];
export declare const getHeight: (size: number) => number;
export declare const getBinaryString: (nodeIndex: number, length: number) => Buffer;
export declare const getRightSiblingInfo: (nodeIndex: number, layerIndex: number, size: number) => NodeLocation | undefined;
export declare const calculateMerkleRoot: ({ value, appendPath, size }: MerkleRootInfo) => {
    root: Buffer;
    appendPath: Buffer[];
    size: number;
};
export declare const largestPowerOfTwoSmallerThan: (size: number) => number;
export declare const calculateMerkleRootWithLeaves: (data: Buffer[]) => Buffer;
export declare const isLeft: (index: number) => boolean;
export declare const isSameLayer: (index1: number, index2: number) => boolean;
export declare const areSiblings: (index1: number, index2: number) => boolean;
export declare const treeSortFn: (a: number, b: number) => number;
export declare const insertNewIndex: (arr: number[], val: number) => void;
export declare const getLocation: (index: number, height: number) => NodeLocation;
export declare const toIndex: (nodeIndex: number, layerIndex: number, height: number) => number;
export declare const ROOT_INDEX = 2;
export declare const calculatePathNodes: (queryHashes: ReadonlyArray<Buffer>, size: number, idxs: ReadonlyArray<number>, siblingHashes: ReadonlyArray<Buffer>) => Map<number, Buffer>;
