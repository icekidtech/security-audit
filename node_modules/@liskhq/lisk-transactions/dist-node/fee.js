"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeMinFee = exports.DEFAULT_SIGNATURE_BYTE_SIZE = exports.DEFAULT_NUMBER_OF_SIGNATURES = exports.DEFAULT_MIN_FEE_PER_BYTE = void 0;
const sign_1 = require("./sign");
exports.DEFAULT_MIN_FEE_PER_BYTE = 1000;
exports.DEFAULT_NUMBER_OF_SIGNATURES = 1;
exports.DEFAULT_SIGNATURE_BYTE_SIZE = 64;
const computeMinFee = (trx, assetSchema, options) => {
    var _a, _b, _c;
    const mockSignatures = new Array((_a = options === null || options === void 0 ? void 0 : options.numberOfSignatures) !== null && _a !== void 0 ? _a : exports.DEFAULT_NUMBER_OF_SIGNATURES).fill(Buffer.alloc(exports.DEFAULT_SIGNATURE_BYTE_SIZE));
    if (options === null || options === void 0 ? void 0 : options.numberOfEmptySignatures) {
        mockSignatures.push(...new Array(options.numberOfEmptySignatures).fill(Buffer.alloc(0)));
    }
    const { ...transaction } = trx;
    transaction.signatures = mockSignatures;
    transaction.fee = BigInt(0);
    const additionalFee = (_b = options === null || options === void 0 ? void 0 : options.additionalFee) !== null && _b !== void 0 ? _b : BigInt(0);
    let minFee = additionalFee;
    do {
        transaction.fee = minFee;
        const transactionSize = (0, sign_1.getBytes)(transaction, assetSchema).length;
        minFee =
            BigInt(transactionSize * ((_c = options === null || options === void 0 ? void 0 : options.minFeePerByte) !== null && _c !== void 0 ? _c : exports.DEFAULT_MIN_FEE_PER_BYTE)) +
                additionalFee;
    } while (minFee > BigInt(transaction.fee));
    return minFee;
};
exports.computeMinFee = computeMinFee;
//# sourceMappingURL=fee.js.map