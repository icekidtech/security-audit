"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signMultiSignatureTransactionWithPrivateKey = exports.signTransactionWithPrivateKey = exports.signMultiSignatureTransaction = exports.signTransaction = exports.getBytes = exports.getSigningBytes = void 0;
const lisk_codec_1 = require("@liskhq/lisk-codec");
const lisk_cryptography_1 = require("@liskhq/lisk-cryptography");
const validate_1 = require("./validate");
const schema_1 = require("./schema");
const constants_1 = require("./constants");
const getSigningBytes = (transactionObject, paramsSchema) => {
    const validationErrors = (0, validate_1.validateTransaction)(transactionObject, paramsSchema);
    if (validationErrors) {
        throw validationErrors;
    }
    if (typeof transactionObject.params !== 'object' ||
        transactionObject.params === null ||
        !paramsSchema) {
        const transactionBytes = lisk_codec_1.codec.encode(schema_1.baseTransactionSchema, {
            ...transactionObject,
            params: Buffer.alloc(0),
            signatures: [],
        });
        return transactionBytes;
    }
    const paramsBytes = lisk_codec_1.codec.encode(paramsSchema, transactionObject.params);
    const transactionBytes = lisk_codec_1.codec.encode(schema_1.baseTransactionSchema, {
        ...transactionObject,
        params: paramsBytes,
        signatures: [],
    });
    return transactionBytes;
};
exports.getSigningBytes = getSigningBytes;
const getBytes = (transactionObject, paramsSchema) => {
    if (typeof transactionObject.params !== 'object' ||
        transactionObject.params === null ||
        !paramsSchema) {
        const transactionBytes = lisk_codec_1.codec.encode(schema_1.baseTransactionSchema, {
            ...transactionObject,
            params: Buffer.alloc(0),
        });
        return transactionBytes;
    }
    const paramsBytes = lisk_codec_1.codec.encode(paramsSchema, transactionObject.params);
    const transactionBytes = lisk_codec_1.codec.encode(schema_1.baseTransactionSchema, {
        ...transactionObject,
        params: paramsBytes,
    });
    return transactionBytes;
};
exports.getBytes = getBytes;
const signTransaction = (transactionObject, chainID, privateKey, paramsSchema) => {
    if (!chainID.length) {
        throw new Error('ChainID is required to sign a transaction');
    }
    if (!privateKey.length || privateKey.length !== 64) {
        throw new Error('Private key must be 64 bytes');
    }
    const validationErrors = (0, validate_1.validateTransaction)(transactionObject, paramsSchema);
    if (validationErrors) {
        throw validationErrors;
    }
    const signature = lisk_cryptography_1.ed.signDataWithPrivateKey(constants_1.TAG_TRANSACTION, chainID, (0, exports.getSigningBytes)(transactionObject, paramsSchema), privateKey);
    transactionObject.signatures = [signature];
    return { ...transactionObject, id: lisk_cryptography_1.utils.hash((0, exports.getBytes)(transactionObject, paramsSchema)) };
};
exports.signTransaction = signTransaction;
const signMultiSignatureTransaction = (transactionObject, chainID, privateKey, keys, paramsSchema) => {
    if (!chainID.length) {
        throw new Error('ChainID is required to sign a transaction');
    }
    if (!privateKey || privateKey.length !== 64) {
        throw new Error('Private key must be 64 bytes');
    }
    if (!Array.isArray(transactionObject.signatures)) {
        throw new Error('Signatures must be of type array');
    }
    const validationErrors = (0, validate_1.validateTransaction)(transactionObject, paramsSchema);
    if (validationErrors) {
        throw validationErrors;
    }
    keys.mandatoryKeys.sort((publicKeyA, publicKeyB) => publicKeyA.compare(publicKeyB));
    keys.optionalKeys.sort((publicKeyA, publicKeyB) => publicKeyA.compare(publicKeyB));
    const signature = lisk_cryptography_1.ed.signDataWithPrivateKey(constants_1.TAG_TRANSACTION, chainID, (0, exports.getSigningBytes)(transactionObject, paramsSchema), privateKey);
    const publicKey = lisk_cryptography_1.ed.getPublicKeyFromPrivateKey(privateKey);
    const accountKeys = keys.mandatoryKeys.concat(keys.optionalKeys);
    for (let i = 0; i < accountKeys.length; i += 1) {
        if (accountKeys[i].equals(publicKey)) {
            transactionObject.signatures[i] = signature;
        }
        else if (transactionObject.signatures[i] === undefined) {
            transactionObject.signatures[i] = Buffer.alloc(0);
        }
    }
    return { ...transactionObject, id: lisk_cryptography_1.utils.hash((0, exports.getBytes)(transactionObject, paramsSchema)) };
};
exports.signMultiSignatureTransaction = signMultiSignatureTransaction;
exports.signTransactionWithPrivateKey = exports.signTransaction;
exports.signMultiSignatureTransactionWithPrivateKey = exports.signMultiSignatureTransaction;
//# sourceMappingURL=sign.js.map