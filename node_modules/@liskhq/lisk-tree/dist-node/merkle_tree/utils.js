"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculatePathNodes = exports.ROOT_INDEX = exports.toIndex = exports.getLocation = exports.insertNewIndex = exports.treeSortFn = exports.areSiblings = exports.isSameLayer = exports.isLeft = exports.calculateMerkleRootWithLeaves = exports.largestPowerOfTwoSmallerThan = exports.calculateMerkleRoot = exports.getRightSiblingInfo = exports.getBinaryString = exports.getHeight = exports.getLayerStructure = exports.getMaxIdxAtLayer = exports.generateHash = exports.isLeaf = void 0;
const lisk_cryptography_1 = require("@liskhq/lisk-cryptography");
const utils_1 = require("../utils");
const constants_1 = require("./constants");
const isLeaf = (value) => value[0] === constants_1.LEAF_PREFIX[0];
exports.isLeaf = isLeaf;
const generateHash = (prefix, leftHash, rightHash) => lisk_cryptography_1.utils.hash(Buffer.concat([prefix, leftHash, rightHash], prefix.length + leftHash.length + rightHash.length));
exports.generateHash = generateHash;
const getMaxIdxAtLayer = (layer, size) => {
    let [max, r] = [size, 0];
    for (let i = 0; i < layer; i += 1) {
        [max, r] = [[Math.floor, Math.ceil][r % 2](max / 2), r + (max % 2)];
    }
    return max;
};
exports.getMaxIdxAtLayer = getMaxIdxAtLayer;
const getLayerStructure = (size) => {
    const structure = [];
    for (let i = 0; i <= Math.ceil(Math.log2(size)); i += 1) {
        structure.push((0, exports.getMaxIdxAtLayer)(i, size));
    }
    return structure;
};
exports.getLayerStructure = getLayerStructure;
const getHeight = (size) => Math.ceil(Math.log2(size)) + 1;
exports.getHeight = getHeight;
const getBinaryString = (nodeIndex, length) => {
    if (length === 0) {
        return Buffer.alloc(0);
    }
    let binaryString = nodeIndex.toString(2);
    while (binaryString.length < length) {
        binaryString = `0${binaryString}`;
    }
    return Buffer.from(binaryString, 'utf8');
};
exports.getBinaryString = getBinaryString;
const getRightSiblingInfo = (nodeIndex, layerIndex, size) => {
    const structure = (0, exports.getLayerStructure)(size);
    let siblingNodeIndex = ((nodeIndex >>> 1) << 1) + ((nodeIndex + 1) % 2);
    let siblingLayerIndex = layerIndex;
    while (siblingNodeIndex >= structure[siblingLayerIndex] && siblingLayerIndex > 0) {
        siblingNodeIndex <<= 1;
        siblingLayerIndex -= 1;
    }
    if (siblingNodeIndex >= size) {
        return undefined;
    }
    return {
        nodeIndex: siblingNodeIndex,
        layerIndex: siblingLayerIndex,
    };
};
exports.getRightSiblingInfo = getRightSiblingInfo;
const calculateMerkleRoot = ({ value, appendPath, size }) => {
    const leafValueWithPrefix = Buffer.concat([constants_1.LEAF_PREFIX, value], constants_1.LEAF_PREFIX.length + value.length);
    const newLeafHash = lisk_cryptography_1.utils.hash(leafValueWithPrefix);
    let currentHash = newLeafHash;
    let count = 0;
    const binaryLength = size.toString(2);
    for (let i = 0; i < binaryLength.length; i += 1) {
        if ((size >> i) & 1) {
            const siblingHash = appendPath[count];
            currentHash = (0, exports.generateHash)(constants_1.BRANCH_PREFIX, siblingHash, currentHash);
            count += 1;
        }
    }
    const newRoot = currentHash;
    let subTreeIndex;
    const treeHeight = Math.ceil(Math.log2(size)) + 1;
    for (subTreeIndex = 0; subTreeIndex < treeHeight; subTreeIndex += 1) {
        if (!((size >> subTreeIndex) & 1)) {
            break;
        }
    }
    const currentAppendPath = appendPath.slice(0);
    currentHash = newLeafHash;
    const splicedPath = currentAppendPath.splice(subTreeIndex);
    for (const sibling of currentAppendPath) {
        currentHash = (0, exports.generateHash)(constants_1.BRANCH_PREFIX, sibling, currentHash);
    }
    const newAppendPath = [currentHash].concat(splicedPath);
    return { root: newRoot, appendPath: newAppendPath, size: size + 1 };
};
exports.calculateMerkleRoot = calculateMerkleRoot;
const largestPowerOfTwoSmallerThan = (size) => 2 ** Math.floor(Math.log2(size - 1));
exports.largestPowerOfTwoSmallerThan = largestPowerOfTwoSmallerThan;
const calculateMerkleRootWithLeaves = (data) => {
    if (data.length === 0) {
        return constants_1.EMPTY_HASH;
    }
    if (data.length === 1) {
        const leafValueWithPrefix = Buffer.concat([constants_1.LEAF_PREFIX, data[0]], constants_1.LEAF_PREFIX.length + data[0].length);
        return lisk_cryptography_1.utils.hash(leafValueWithPrefix);
    }
    const k = (0, exports.largestPowerOfTwoSmallerThan)(data.length);
    const leftTree = data.slice(0, k);
    const rightTree = data.slice(k, data.length);
    return (0, exports.generateHash)(constants_1.BRANCH_PREFIX, (0, exports.calculateMerkleRootWithLeaves)(leftTree), (0, exports.calculateMerkleRootWithLeaves)(rightTree));
};
exports.calculateMerkleRootWithLeaves = calculateMerkleRootWithLeaves;
const isLeft = (index) => (index & 1) === 0;
exports.isLeft = isLeft;
const isSameLayer = (index1, index2) => index1.toString(2).length === index2.toString(2).length;
exports.isSameLayer = isSameLayer;
const areSiblings = (index1, index2) => (index1 ^ index2) === 1;
exports.areSiblings = areSiblings;
const treeSortFn = (a, b) => {
    if (a.toString(2).length === b.toString(2).length) {
        return a - b;
    }
    return b - a;
};
exports.treeSortFn = treeSortFn;
const insertNewIndex = (arr, val) => {
    const insertIndex = (0, utils_1.binarySearch)(arr, n => (0, exports.treeSortFn)(val, n) <= 0);
    if (arr[insertIndex] !== val) {
        arr.splice(insertIndex, 0, val);
    }
};
exports.insertNewIndex = insertNewIndex;
const getLocation = (index, height) => {
    const serializedIndexBinaryString = index.toString(2);
    const indexBinaryString = serializedIndexBinaryString.substring(1, serializedIndexBinaryString.length);
    const layerIndex = height - indexBinaryString.length;
    if (layerIndex < 0) {
        throw new Error(`Invalid index ${index} with height ${height}`);
    }
    const location = {
        nodeIndex: parseInt(indexBinaryString, 2),
        layerIndex,
    };
    return location;
};
exports.getLocation = getLocation;
const toIndex = (nodeIndex, layerIndex, height) => {
    const length = height - layerIndex;
    if (length <= 0) {
        throw new Error(`Invalid height ${height} or layer index ${layerIndex}`);
    }
    let binaryString = nodeIndex.toString(2);
    while (binaryString.length < length) {
        binaryString = `0${binaryString}`;
    }
    return parseInt(`1${binaryString}`, 2);
};
exports.toIndex = toIndex;
exports.ROOT_INDEX = 2;
const calculatePathNodes = (queryHashes, size, idxs, siblingHashes) => {
    var _a, _b;
    const copiedSiblingHashes = [...siblingHashes];
    const tree = new Map();
    if (queryHashes.length === 0 || idxs.length === 0) {
        throw new Error('Invalid input. QueryHashes and Indexes must have at least one element.');
    }
    if (queryHashes.length !== idxs.length) {
        throw new Error('Invalid input. QueryHashes and Indexes must match.');
    }
    let sortedIdxs = [];
    for (let i = 0; i < idxs.length; i += 1) {
        const idx = idxs[i];
        if (idx === 0) {
            continue;
        }
        const query = queryHashes[i];
        sortedIdxs.push(idx);
        tree.set(idx, query);
    }
    sortedIdxs.sort(exports.treeSortFn);
    const height = (0, exports.getHeight)(size);
    const parentCache = new Map();
    while (sortedIdxs.length > 0) {
        const idx = sortedIdxs[0];
        if (idx === exports.ROOT_INDEX) {
            return tree;
        }
        const currentHash = (_a = tree.get(idx)) !== null && _a !== void 0 ? _a : parentCache.get(idx);
        const parentIdx = idx >>> 1;
        if (!currentHash) {
            throw new Error(`Invalid state. Hash for index ${idx} should exist.`);
        }
        const currentLoc = (0, exports.getLocation)(idx, height);
        const siblingLoc = (0, exports.getRightSiblingInfo)(currentLoc.nodeIndex, currentLoc.layerIndex, size);
        if (siblingLoc) {
            const siblingIdx = (0, exports.toIndex)(siblingLoc.nodeIndex, siblingLoc.layerIndex, height);
            const siblingHash = (_b = tree.get(siblingIdx)) !== null && _b !== void 0 ? _b : copiedSiblingHashes.splice(0, 1)[0];
            const parentHash = (0, exports.isLeft)(idx)
                ? (0, exports.generateHash)(constants_1.BRANCH_PREFIX, currentHash, siblingHash)
                : (0, exports.generateHash)(constants_1.BRANCH_PREFIX, siblingHash, currentHash);
            const existingParentHash = tree.get(parentIdx);
            if (existingParentHash !== undefined && !parentHash.equals(existingParentHash)) {
                throw new Error('Invalid query hashes. Calculated parent hash does not match.');
            }
            tree.set(parentIdx, parentHash);
        }
        else {
            parentCache.set(parentIdx, currentHash);
        }
        sortedIdxs = sortedIdxs.slice(1);
        (0, exports.insertNewIndex)(sortedIdxs, parentIdx);
    }
    return tree;
};
exports.calculatePathNodes = calculatePathNodes;
//# sourceMappingURL=utils.js.map