"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateRightWitness = exports.verifyRightWitness = exports.calculateRootFromRightWitness = void 0;
const lisk_cryptography_1 = require("@liskhq/lisk-cryptography");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const popFirst = (val) => {
    const [first] = val;
    val.splice(0, 1);
    return first;
};
const getRootFromPath = (paths) => {
    if (!paths.length) {
        throw new Error('Invalid append path');
    }
    let [currentHash] = paths;
    for (let index = 1; index < paths.length; index += 1) {
        currentHash = (0, utils_1.generateHash)(constants_1.BRANCH_PREFIX, paths[index], currentHash);
    }
    return currentHash;
};
const calculateRootFromRightWitness = (idx, appendPath, rightWitness) => {
    if (!appendPath.length) {
        return getRootFromPath(rightWitness);
    }
    if (!rightWitness.length) {
        return getRootFromPath(appendPath);
    }
    const updatingAppendPath = appendPath.slice();
    const updatingRightWitness = rightWitness.slice();
    let layerIndex = 0;
    let incrementalIdx = idx;
    const firstAppendPath = popFirst(updatingAppendPath);
    const firstRightWitness = popFirst(updatingRightWitness);
    let currentHash = (0, utils_1.generateHash)(constants_1.BRANCH_PREFIX, firstAppendPath, firstRightWitness);
    let incrementalIdxInitialized = false;
    while (updatingAppendPath.length > 0 || updatingRightWitness.length > 0) {
        const idxDigit = (idx >>> layerIndex) & 1;
        if (updatingAppendPath.length > 0 && idxDigit === 1) {
            if (!incrementalIdxInitialized) {
                incrementalIdx += 1 << layerIndex;
                incrementalIdxInitialized = true;
            }
            else {
                const leftHash = popFirst(updatingAppendPath);
                currentHash = (0, utils_1.generateHash)(constants_1.BRANCH_PREFIX, leftHash, currentHash);
            }
        }
        const incrementalIdxDigit = (incrementalIdx >>> layerIndex) & 1;
        if (updatingRightWitness.length > 0 && incrementalIdxDigit === 1) {
            const rightHash = popFirst(updatingRightWitness);
            currentHash = (0, utils_1.generateHash)(constants_1.BRANCH_PREFIX, currentHash, rightHash);
            incrementalIdx += 1 << layerIndex;
        }
        layerIndex += 1;
    }
    return currentHash;
};
exports.calculateRootFromRightWitness = calculateRootFromRightWitness;
const verifyRightWitness = (idx, appendPath, rightWitness, root) => {
    const calculatedRoot = (0, exports.calculateRootFromRightWitness)(idx, appendPath, rightWitness);
    return calculatedRoot.equals(root);
};
exports.verifyRightWitness = verifyRightWitness;
const calculateRightWitness = (size, values) => {
    if (size === 0) {
        throw new Error('witness cannot be generated for empty tree.');
    }
    if (values.length === 0) {
        return [];
    }
    let hashes = [];
    for (const data of values) {
        const leafValueWithoutNodeIndex = Buffer.concat([constants_1.LEAF_PREFIX, data], constants_1.LEAF_PREFIX.length + data.length);
        const leafHash = lisk_cryptography_1.utils.hash(leafValueWithoutNodeIndex);
        hashes.push(leafHash);
    }
    const witness = [];
    const height = (0, utils_1.getHeight)(size + hashes.length);
    let incrementalIdx = size;
    for (let layerIndex = 0; layerIndex < height; layerIndex += 1) {
        if (hashes.length === 0) {
            break;
        }
        const digit = (incrementalIdx >>> layerIndex) & 1;
        if (digit === 1) {
            const [removed] = hashes.splice(0, 1);
            witness.push(removed);
            incrementalIdx += 1 << layerIndex;
        }
        const nextHashes = [];
        for (let i = 0; i < hashes.length; i += 2) {
            if (i + 1 < hashes.length) {
                nextHashes.push((0, utils_1.generateHash)(constants_1.BRANCH_PREFIX, hashes[i], hashes[i + 1]));
            }
            else {
                nextHashes.push(hashes[i]);
            }
        }
        hashes = nextHashes;
    }
    return witness;
};
exports.calculateRightWitness = calculateRightWitness;
//# sourceMappingURL=right_witness.js.map